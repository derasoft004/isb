"""
Зюзин Е. В. 6211

./task_1 - directory for executing the first task
     common_text.txt - plain text for further encryption
     encrypted_text.txt - encrypted text
     key.json - encryption key generated by the algorithm described in the rot16 function

./task_2 - directory for executing the second task
     cod8.txt - encrypted text for further processing and decryption
     decipher_text.txt - deciphered text
     key.json - selected encryption key

"""
from constants import *


def read_file(file_name: str) -> str:
    """
    reading file

    :param file_name: path to file
    :return:  string in one line (withoun \n)
    """
    with open(file_name, 'r') as file:
        return_obj = ''.join(file.readlines())
    return return_obj


def write_file(file_name: str, data: str) -> None:
    """
    writing to file

    :param file_name: path to file
    :param data: data for writing
    :return None:
    """
    with open(file_name, 'w') as file:
        file.write(data)


def dump_to_json(data, file_name: str) -> None:
    """
    writing to json file keys using RU-symbols

    :param data:
    :param file_name:
    :return:
    """
    with open(file_name, 'w') as file:
        json.dump(data, file, ensure_ascii=False)



def rot16(string: str) -> str:
    """
    function rot16 (modified rot13 or 'Caesar's cipher'), realised using symbol's code shift of 16 (half of 32)
    'if c.isalpha()' is a check that this symbol is a letter:
        1) if it is -> do step in 16 symbols in alphabet; using half 32 we need only check symbol's place:
            if symbol in right part of alphabet -> step left
            else -> step right
        2) if it isn't -> don't change

    :param string:
    :return:
    """

    return ''.join(map(lambda c: chr(ord(c) + 16) if c.isalpha() and c.lower() <= 'п' else
        chr(ord(c) - 16) if c.isalpha() else c, string))


def task_1(path_file_to_read: str, path_file_to_write: str) -> None:
    """
    writing encrypted text to file using function rot16

    :param path_file_to_read:
    :param path_file_to_write:
    :return:
    """
    write_file(path_file_to_write, rot16(read_file(path_file_to_read)))


def global_symbols_frequency(path: str) -> dict:
    """
    count stat for symbols in global using

    :return:
    """
    try:
        frequency_lst = read_file(path).split('\n')
    except OSError as e:
        print('error func "global_symbols_frequency": ', e)
        return {}
    dictionary = dict()
    symbols, frequency = \
        [frequency_lst[i][0] for i in range(len(frequency_lst))], \
        [float(frequency_lst[i][4:12]) for i in range(len(frequency_lst))]

    for ind, key in enumerate(symbols):
        dictionary[key] = frequency[ind]
    return dictionary


def encrypted_text_symbols_frequency(path: str) -> dict:
    """
    complete dictionary with symbols frequency in the text

    :param path:
    :return: text's symbols dictionary
    """
    try:
        encrypted_text = read_file(path)
    except OSError as e:
        print('error func "encrypted_text_symbols_frequency": ', e)
        return {}
    symbols_dict = dict()
    for key in set(encrypted_text):
        symbols_dict[key] = float(round(encrypted_text.count(key) / len(encrypted_text), 6))
    return symbols_dict


def task_2(path_encrypted_text: str, path_key: str, path_write_file: str) -> None:
    """
    decoding the cod8 using the key
    key is got after get_equals_dict and selection the right symbols

    :param path_key:
    :param path_encrypted_text:
    :param path_write_file:
    :return:
    """
    try:
        encrypted_text = read_file(path_encrypted_text)
    except OSError as e:
        print('error func "task_2": ', e)
        return
    ret_str = ''

    with open(path_key) as f:
        key = json.load(f)

    for symbol in encrypted_text:
        try:
            ret_str += key[symbol]
        except KeyError:
            ret_str += symbol
    try:
        write_file(path_write_file, ret_str)
    except OSError as e:
        print('error func "task_2": ', e)
        return


def main(l1_common_text: str, l1_encrypted_text: str, l2_cod8: str, l2_key: str, l2_decipher_text: str) -> None:
    try:
        task_1(l1_common_text, l1_encrypted_text)
        task_2(l2_cod8, l2_key, l2_decipher_text)
    except Exception as e:
        print('main error: ', e)


if __name__ == '__main__':
    main(T1_COMMON_TEXT, T1_ENCRYPTED_TEXT,
         T2_COD8, T2_KEY, T2_DECIPHER_TEXT)
